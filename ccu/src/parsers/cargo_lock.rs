use check_updates_core::Version;
use anyhow::{Context, Result};
use std::collections::HashMap;
use std::fs;
use std::path::PathBuf;
use std::str::FromStr;
use toml::Value;

/// Parser for Cargo.lock files
pub struct CargoLockParser;

impl CargoLockParser {
    pub fn new() -> Self {
        Self
    }

    /// Parse Cargo.lock and return a map of package name to installed version
    pub fn parse(&self, path: &PathBuf) -> Result<HashMap<String, Version>> {
        let content = fs::read_to_string(path)
            .with_context(|| format!("Failed to read {}", path.display()))?;

        let parsed: Value = toml::from_str(&content)
            .with_context(|| format!("Failed to parse TOML in {}", path.display()))?;

        let mut versions = HashMap::new();

        // Parse [[package]] sections
        if let Some(packages) = parsed.get("package").and_then(|v| v.as_array()) {
            for package in packages {
                if let (Some(name), Some(version_str)) = (
                    package.get("name").and_then(|v| v.as_str()),
                    package.get("version").and_then(|v| v.as_str()),
                ) {
                    if let Ok(version) = Version::from_str(version_str) {
                        // Note: There can be multiple versions of the same crate
                        // We'll store the highest version
                        versions
                            .entry(name.to_string())
                            .and_modify(|existing: &mut Version| {
                                if version > *existing {
                                    *existing = version.clone();
                                }
                            })
                            .or_insert(version);
                    }
                }
            }
        }

        Ok(versions)
    }

    /// Find Cargo.lock in project and parse it
    pub fn find_and_parse(&self, project_path: &PathBuf) -> Result<HashMap<String, Version>> {
        let lock_path = project_path.join("Cargo.lock");

        if lock_path.exists() {
            self.parse(&lock_path)
        } else {
            // No lock file, return empty map
            Ok(HashMap::new())
        }
    }
}

impl Default for CargoLockParser {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;

    #[test]
    fn test_parse_cargo_lock() -> Result<()> {
        let mut file = NamedTempFile::new()?;
        writeln!(
            file,
            r#"
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "serde"
version = "1.0.200"
source = "registry+https://github.com/rust-lang/crates.io-index"

[[package]]
name = "tokio"
version = "1.37.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
"#
        )?;

        let parser = CargoLockParser::new();
        let versions = parser.parse(&file.path().to_path_buf())?;

        assert_eq!(versions.len(), 2);
        assert_eq!(versions.get("serde").unwrap().to_string(), "1.0.200");
        assert_eq!(versions.get("tokio").unwrap().to_string(), "1.37.0");

        Ok(())
    }

    #[test]
    fn test_multiple_versions_same_crate() -> Result<()> {
        let mut file = NamedTempFile::new()?;
        writeln!(
            file,
            r#"
version = 3

[[package]]
name = "syn"
version = "1.0.109"

[[package]]
name = "syn"
version = "2.0.60"
"#
        )?;

        let parser = CargoLockParser::new();
        let versions = parser.parse(&file.path().to_path_buf())?;

        // Should have the highest version
        assert_eq!(versions.get("syn").unwrap().to_string(), "2.0.60");

        Ok(())
    }
}
